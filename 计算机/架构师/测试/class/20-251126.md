1.面向对象，面向类，面向过程
	面向对象指针对事件相同的特性抽象成类，每次调用针对对象
		类中取一个冰箱和大象
		冰箱打开门
		大象进冰箱
	面向过程指只关注事件调用的过程，不关注事件的对象
		买一个冰箱和大象
		打开冰箱门
		放入大象
2.`hasattr(object, name)`
	
	**功能**：检查对象是否具有指定的属性或方法
	
	**参数**：
	
	- `object`：要检查的对象
	    
	- `name`：属性/方法的名称（字符串）
	    
	
	**返回值**：布尔值
	
	- `True`：对象有该属性/方法
	    
	- `False`：对象没有该属性/方法
3.`getattr(object, name)`
	
	**功能**：获取对象的属性或方法
	
	**参数**：
	
	- `object`：要获取属性的对象
	    
	- `name`：属性/方法的名称（字符串）
	    
	**返回值**：对应的属性值或方法引用
4.`isinstance(object, classinfo)`

	**功能**：检查对象是否**是**某个类或其子类的实例  
	**关注点**：对象的类型/继承关系
5.@classmethod,声明类方法，@dataclass,声明一个类，@staticmethod,声明静态方法
	1.@classmethod
	def func(cls):
	其中默认参数cls声明的变量是全局共享可的，cls表示当前类
	2.@staticmethod
	def func()：
	其中不传入任何参数，不对类和属性进行任何处理，与类没有任何关联
#### 6.
```python
from dataclasses import dataclass

from typing import Optional

@dataclass

class Elephant:

    name:    str = '大象'

    weight:  int = 9999

    color:   Optional[str] = '粉色'

    contant: str = '冰箱'

    def action_1(self):

        print(f"打开{self.contant}")

    def action_2(self):

        print(f"把{self.color}kg的{self.name}放进{self.contant}")

    def action_3(self):

        print(f"关闭{self.contant}")

  

a = Elephant()

for i in range(1,4):

    s = f"action_{i}"

    getattr(a,s)()
```
输出：打开冰箱 把粉色kg的大象放进冰箱 关闭冰箱
7.包和模块
# 一.封装、继承、多态
#### 1.封装
私有化。其指的是将数据（属性）和行为（方法）捆绑在一起，并隐藏对象的内部状态和实现细节，仅对外提供公开的访问方式。封装的主要目的是增强安全性和简化编程，使用者不需要了解具体的实现细节，而只需要通过外部接口即可使用类的功能。
无下划线： 公共属性
单下划线： 受保护的属性
双下划线： 私有属性
self.`__`name = name
def `_`func:
#### 2.继承
允许我们定义一个类，该类继承另一个类的属性和方法。被继承的类称为父类（或基类），继承的类称为子类（派生类）。子类可以重写或扩展父类的功能。
	子类(父类)，子类继承父类属性或方法。也可使用super()调用
```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        raise NotImplementedError("子类必须实现此方法")

class Dog(Animal):
    def speak(self):
        return "汪汪！"

class Cat(Animal):
    def speak(self):
        return "喵喵！"

# 使用
dog = Dog("旺财")
cat = Cat("咪咪")
print(dog.speak())  # 输出：汪汪！
print(cat.speak())  # 输出：喵喵！
```
#### 3.多态
是指同一个方法调用在不同对象上会产生不同的行为。多态允许我们使用统一的接口来操作不同的对象。
	def func(a):
```python
def animal_speak(animal):
    print(animal.speak())

# 使用多态
animal_speak(dog)  # 输出：汪汪！
animal_speak(cat)  # 输出：喵喵！
```
举例
```python
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        return "动物发出声音"
    
    def move(self):
        return f"{self.name}在移动"

class Dog(Animal):  # Dog 继承 Animal
    def __init__(self, name, breed):
        super().__init__(name)  # 调用父类的构造方法
        self.breed = breed
    
    # 重写父类方法
    def speak(self):
        return "汪汪！"

class Cat(Animal):  # Cat 继承 Animal
    def __init__(self, name, color):
        super().__init__(name)
        self.color = color
    
    # 重写父类方法
    def speak(self):
        return "喵喵！"

# 使用
dog = Dog("旺财", "金毛")
cat = Cat("咪咪", "白色")

print(dog.speak())  # 输出: 汪汪！
print(cat.speak())  # 输出: 喵喵！
print(dog.move())   # 输出: 旺财在移动 (继承自父类)
```