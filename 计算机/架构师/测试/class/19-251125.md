1.迭代器与生成器
	迭代器是使用iter方法，把一个可选代对象转化成的选代器对象，生成器是一个函数，而且函数中含有yeild
	迭代器可使用iter方法和next方法，生成器只能使用next方法。
	每一个迭代器都不是生成器，生成器可能是迭代器。
	迭代器是访问集合的一种方式
	迭代器节约内存，生成器既节约内存又节约cpu
2.匿名函数
	lambda 参数列表: 表达式
	s = lamba a,b:a+b
3.闭包
	函数内嵌套一个函数，外部函数返回时返回内部函数。内部函数可以调用外部函数的声明。下列函数中，func2中的a的值也为666。设置了只有内部函数的局部变量，避免了全局污染。
```python
def  func1（）:
	表达式a =666
	def func2() :
		表达式a
	retun func2
b=func1() 
```
4.语法糖
	@func。在函数1上面加上@另一个函数名 2,的作用是将这个修饰符下面的函数1作为该修饰符函数2的参数传入。下图中将func()作为func1的参数输入，即装饰了dunc2。
```python
@func1
def fun()
```
5.装饰器 (@闭包函数)
	在不修改原有代码基础上，添加额外功能。将sum作为func的s输入，进入内部函数返回给外层inner，因此sum等价于func等价于inner。
```python
import time
def decorator(func):
    def inner(*args,**kwargs):
        start = time.time()
        func(a,b) # func(*args)
        end = time.time()
        print("Time taken:", end - start)
    return inner
@func
def sum(a, b):
    return a + b
sum(5, 10)
```
6.拷贝
	b=a 赋值，对a的数据进行拷贝。
	c=copy.copy(a) 浅拷贝，对a的地址进行拷贝。当a中的值更新后，若生成了新的空间，c不变。可变值改变互相影响；不可变值互不影响。同一内存
	d=deepcopy(a) 深拷贝，把a的地址和数据一起拷贝。备份，无论可变值还是不可变值都与a没有影响。不在同一内存