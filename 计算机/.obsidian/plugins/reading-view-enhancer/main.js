/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ReadingViewEnhancer
});
module.exports = __toCommonJS(main_exports);
var import_obsidian18 = require("obsidian");

// src/constants.ts
var MARKDOWN_PREVIEW_VIEW = "markdown-preview-view";
var FRONTMATTER = "frontmatter";
var BLOCKS = [
  "p",
  "li",
  "table",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "pre",
  "blockquote",
  "img",
  "video",
  "audio",
  "iframe",
  "[data-callout]"
];
var BLOCK_SELECTOR = "rve-block-selector";
var BLOCK_ATTR = "data-rve-block";
var SELECTED_BLOCK = "rve-selected-block";
var COLLAPSE_INDICATORS = [".collapse-indicator", ".callout-fold"];
var IS_COLLAPSED = "is-collapsed";

// src/styles.ts
var StyleRule = class {
  constructor(template, injectVariables) {
    this.template = template;
    this.isActive = false;
    this.injectVariables = injectVariables;
  }
  /**
   * Get the rule after injecting variables
   *
   * @returns The rule
   */
  getRule() {
    return this.injectVariables(this.template);
  }
};
var BlockColorRule = class extends StyleRule {
  constructor() {
    const template = `
			.${SELECTED_BLOCK} {
				position: relative;
				z-index: 0;
			}
			
			.${SELECTED_BLOCK}::before {
				content: "";
				position: absolute;
				z-index: -1;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				pointer-events: none;
				background-color: {{BLOCK_COLOR}};
			}
		`;
    super(template, (template2) => {
      const percentage = this.transparency / 100;
      const transparencyApplied = this.color.replace(
        /\d+\s*\)$/,
        percentage + ")"
      );
      return template2.replace("{{BLOCK_COLOR}}", transparencyApplied);
    });
    this.isActive = true;
  }
  /**
   * Set the block color
   *
   * @param blockColor {string} The block color
   */
  set(blockColor) {
    this.color = blockColor.color;
    this.transparency = blockColor.transparency;
  }
};
var CollapseIndicatorAlwaysOnRule = class extends StyleRule {
  constructor() {
    const template = `
			.markdown-reading-view .markdown-preview-section .collapse-indicator {
				opacity: 1;
			}
		`;
    super(template, (template2) => template2);
  }
};
var CollapseIndicatorOnTheRightSideRule = class extends StyleRule {
  constructor() {
    const template = `
			.markdown-reading-view .markdown-preview-section>div:not([class="markdown-preview-pusher"]),
			.markdown-reading-view .markdown-preview-section>div:not([class="mod-header"]) {
					position: relative;
			}

			.markdown-reading-view .markdown-preview-section .collapse-indicator {
					right: -1rem;
					padding-inline-end: 0;
			}

			.markdown-reading-view .markdown-preview-section > div > .has-list-bullet > li {
					margin-inline-start: calc(var(--list-indent) * {{LIST_INDENT}});
			}
		`;
    super(
      template,
      (template2) => template2.replace(
        "{{LIST_INDENT}}",
        this.isCheckboxAligned ? "0.7" : "0.8"
      )
    );
  }
};
var AlignCheckboxToIndentationGuide = class extends StyleRule {
  constructor() {
    const template = `
			.markdown-reading-view ul > li.task-list-item .task-list-item-checkbox {
					margin-inline-start: calc(var(--checkbox-size) * -1.35);
			}
		`;
    super(template, (template2) => template2);
  }
};
var ScrollableCodeRule = class extends StyleRule {
  constructor() {
    const template = `
			.markdown-reading-view .markdown-preview-section div > pre {
				overflow: hidden;
				white-space: pre-wrap;
			}

			.markdown-reading-view .markdown-preview-section div > pre > code {
				display: block;
				overflow: auto;
				white-space: pre;
			}
		`;
    super(template, (template2) => template2);
  }
};
var RveStyles = class {
  constructor() {
    this.styleTag = document.createElement("style");
    this.styleTag.id = "rve-styles";
    document.getElementsByTagName("head")[0].appendChild(this.styleTag);
    this.rules = {
      "block-color": new BlockColorRule(),
      "collapse-indicator-always-on": new CollapseIndicatorAlwaysOnRule(),
      "collapse-indicator-on-the-right-side": new CollapseIndicatorOnTheRightSideRule(),
      "align-checkbox-to-indentation-guide": new AlignCheckboxToIndentationGuide(),
      "scrollable-code": new ScrollableCodeRule()
    };
  }
  /**
   * Clean up the style tag
   */
  cleanup() {
    this.styleTag.remove();
  }
  /**
   * Get a rule by key
   *
   * @param rule rule's key
   * @returns One of the rules
   */
  of(rule) {
    return this.rules[rule];
  }
  /**
   * Apply all active rules
   */
  apply() {
    const style = Object.values(this.rules).filter((rule) => rule.isActive).map((rule) => rule.getRule()).join("\n");
    this.styleTag.innerHTML = style;
  }
};

// src/settings/index.ts
var import_obsidian14 = require("obsidian");

// node_modules/color2k/dist/index.exports.import.es.mjs
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
var ColorError = class extends Error {
  constructor(color) {
    super(`Failed to parse color: "${color}"`);
  }
};
var ColorError$1 = ColorError;
function parseToRgba(color) {
  if (typeof color !== "string")
    throw new ColorError$1(color);
  if (color.trim().toLowerCase() === "transparent")
    return [0, 0, 0, 0];
  let normalizedColor = color.trim();
  normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || "f", 2), 16) / 255];
  }
  const hexMatch = hexRegex.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 16)), parseInt(arr[3] || "ff", 16) / 255];
  }
  const rgbaMatch = rgbaRegex.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 10)), parseFloat(arr[3] || "1")];
  }
  const hslaMatch = hslaRegex.exec(normalizedColor);
  if (hslaMatch) {
    const [h, s, l, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s) !== s)
      throw new ColorError$1(color);
    if (guard(0, 100, l) !== l)
      throw new ColorError$1(color);
    return [...hslToRgb(h, s, l), Number.isNaN(a) ? 1 : a];
  }
  throw new ColorError$1(color);
}
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i) {
    hash2 = hash2 * 33 ^ str.charCodeAt(--i);
  }
  return (hash2 >>> 0) % 2341;
}
var colorToInt = (x) => parseInt(x.replace(/_/g, ""), 36);
var compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next) => {
  const key = colorToInt(next.substring(0, 3));
  const hex = colorToInt(next.substring(3)).toString(16);
  let prefix = "";
  for (let i = 0; i < 6 - hex.length; i++) {
    prefix += "0";
  }
  acc[key] = `${prefix}${hex}`;
  return acc;
}, {});
function nameToHex(color) {
  const normalizedColorName = color.toLowerCase().trim();
  const result = compressedColorMap[hash(normalizedColorName)];
  if (!result)
    throw new ColorError$1(color);
  return `#${result}`;
}
var r = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
var reducedHexRegex = new RegExp(`^#${r("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
var hexRegex = new RegExp(`^#${r("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
var rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
var hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
var namedColorRegex = /^[a-z]+$/i;
var roundColor = (color) => {
  return Math.round(color * 255);
};
var hslToRgb = (hue, saturation, lightness) => {
  let l = lightness / 100;
  if (saturation === 0) {
    return [l, l, l].map(roundColor);
  }
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  const lightnessModification = l - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};
function rgba(red, green, blue, alpha) {
  return `rgba(${guard(0, 255, red).toFixed()}, ${guard(0, 255, green).toFixed()}, ${guard(0, 255, blue).toFixed()}, ${parseFloat(guard(0, 1, alpha).toFixed(3))})`;
}
function toHex(color) {
  const [r2, g, b, a] = parseToRgba(color);
  let hex = (x) => {
    const h = guard(0, 255, x).toString(16);
    return h.length === 1 ? `0${h}` : h;
  };
  return `#${hex(r2)}${hex(g)}${hex(b)}${a < 1 ? hex(Math.round(a * 255)) : ""}`;
}
function toRgba(color) {
  return rgba(...parseToRgba(color));
}

// src/settings/block/block-color.ts
var import_obsidian = require("obsidian");
var BlockColorSetting = class extends import_obsidian.Setting {
  constructor(settingsTabEl, plugin) {
    super(settingsTabEl);
    this.plugin = plugin;
    this.setName("Block color").setDesc(
      "Set background color of the block in reading view. Transparency will be set automatically"
    ).addColorPicker((color) => this.colorPicker(color));
  }
  /**
   * Creates color picker component.
   * Also, creates a button to set color to the current accent color.
   *
   * @param color Color component
   */
  colorPicker(color) {
    const { settings } = this.plugin;
    color.setValue(toHex(settings.blockColor.color)).onChange((changed) => {
      settings.blockColor.color = toRgba(changed);
      this.plugin.saveSettings();
      this.plugin.applyBlockColor(true);
    });
    this.addButton((button) => this.accentColorButton(button, color));
  }
  /**
   * Creates a button to use current accent color.
   * Used in {@link colorPicker}.
   *
   * @param button Button component
   * @param color Color component
   */
  accentColorButton(button, color) {
    button.setButtonText("Use current accent color").onClick(() => {
      const accentColor = this.getAccentColor();
      color.setValue(toHex(accentColor));
      this.plugin.settings.blockColor.color = accentColor;
      this.plugin.saveSettings();
      this.plugin.applyBlockColor(true);
    });
  }
  /**
   * Gets current accent color from Obsidian.
   *
   * @returns Current accent color in hex format
   */
  getAccentColor() {
    const workspaceEl = this.plugin.app.workspace.containerEl;
    const accentColor = toRgba(
      getComputedStyle(workspaceEl).getPropertyValue("--color-accent").trim()
    );
    return accentColor;
  }
};

// src/settings/block/block-transparency.ts
var import_obsidian2 = require("obsidian");
var BlockTransparencySetting = class extends import_obsidian2.Setting {
  constructor(settingsTabEl, plugin) {
    super(settingsTabEl);
    this.plugin = plugin;
    this.setName("Block color transparency").setDesc("Set transparency of the above color.").addSlider((color) => this.transparencySlider(color));
  }
  /**
   * Creates transparency slider component.
   *
   * @param slider Slider component
   */
  transparencySlider(slider) {
    const { settings } = this.plugin;
    slider.setLimits(0, 100, 1).setValue(settings.blockColor.transparency).onChange((changed) => {
      settings.blockColor.transparency = changed;
      this.plugin.saveSettings();
      this.plugin.applyBlockColor(true);
    });
  }
};

// src/settings/block/block-selector.ts
var import_obsidian3 = require("obsidian");
var EnableBlockSelectorSetting = class extends import_obsidian3.Setting {
  constructor(containerEl, plugin) {
    super(containerEl);
    this.plugin = plugin;
    this.setName("Enable block selector").setDesc("Restart is needed to apply changes.").addToggle((toggle) => this.setEnableSelector(toggle));
  }
  /**
   * Creates toggle component that enables/disables block selector.
   *
   * @param toggle {ToggleComponent} Toggle component
   */
  setEnableSelector(toggle) {
    toggle.setValue(this.plugin.settings.enableBlockSelector);
    toggle.onChange((changed) => {
      this.plugin.settings.enableBlockSelector = changed;
      this.plugin.saveSettings();
    });
  }
};

// src/settings/block/block-selector-mobile.ts
var import_obsidian4 = require("obsidian");
var DisableBlockSelectorOnMobileSetting = class extends import_obsidian4.Setting {
  constructor(containerEl, plugin) {
    super(containerEl);
    this.plugin = plugin;
    this.setName("Disable block selector on mobile").setDesc("Restart is needed to apply changes.").addToggle((toggle) => this.setDisableSelectorOnMobile(toggle));
  }
  /**
   * Creates toggle component that enables/disables block selector on mobile.
   *
   * @param toggle {ToggleComponent} Toggle component
   */
  setDisableSelectorOnMobile(toggle) {
    toggle.setValue(this.plugin.settings.disableBlockSelectorOnMobile);
    toggle.onChange((changed) => {
      this.plugin.settings.disableBlockSelectorOnMobile = changed;
      this.plugin.saveSettings();
    });
  }
};

// src/settings/block/index.ts
var BlockSelectorSettings = class {
  constructor(containerEl, plugin) {
    containerEl.createEl("h1", { text: "Block selector" });
    new BlockColorSetting(containerEl, plugin);
    new BlockTransparencySetting(containerEl, plugin);
    new EnableBlockSelectorSetting(containerEl, plugin);
    new DisableBlockSelectorOnMobileSetting(containerEl, plugin);
  }
};

// src/settings/keys/next-block.ts
var import_obsidian5 = require("obsidian");
var NextBlockKeysSetting = class extends import_obsidian5.Setting {
  constructor(containerEl, plugin) {
    super(containerEl);
    this.plugin = plugin;
    this.setName("Next block").setDesc("Keys to select next block.").addTextArea((textArea) => this.setKeys(textArea));
  }
  setKeys(textArea) {
    textArea.setValue(this.plugin.settings.nextBlockKeys);
    textArea.onChange((changed) => {
      this.plugin.settings.nextBlockKeys = changed;
      this.plugin.saveSettings();
    });
  }
};

// src/settings/keys/prev-block.ts
var import_obsidian6 = require("obsidian");
var PrevBlockKeysSetting = class extends import_obsidian6.Setting {
  constructor(containerEl, plugin) {
    super(containerEl);
    this.plugin = plugin;
    this.setName("Previous block").setDesc("Keys to select previous block.").addTextArea((textArea) => this.setKeys(textArea));
  }
  setKeys(textArea) {
    textArea.setValue(this.plugin.settings.prevBlockKeys);
    textArea.onChange((changed) => {
      this.plugin.settings.prevBlockKeys = changed;
      this.plugin.saveSettings();
    });
  }
};

// src/settings/keys/toggle-collapse.ts
var import_obsidian7 = require("obsidian");
var ToggleCollapseKeysSetting = class extends import_obsidian7.Setting {
  constructor(containerEl, plugin) {
    super(containerEl);
    this.plugin = plugin;
    this.setName("Toggle collapse").setDesc("Keys to toggle collapse.").addTextArea((textArea) => this.setKeys(textArea));
  }
  setKeys(textArea) {
    textArea.setValue(this.plugin.settings.toggleCollapseKeys);
    textArea.onChange((changed) => {
      this.plugin.settings.toggleCollapseKeys = changed;
      this.plugin.saveSettings();
    });
  }
};

// src/settings/keys/deselect-block.ts
var import_obsidian8 = require("obsidian");
var DeselectBlockKeysSetting = class extends import_obsidian8.Setting {
  constructor(containerEl, plugin) {
    super(containerEl);
    this.plugin = plugin;
    this.setName("Deselect block").setDesc("Keys to deselect current block.").addTextArea((textArea) => this.setKeys(textArea));
  }
  setKeys(textArea) {
    textArea.setValue(this.plugin.settings.deselectKeys);
    textArea.onChange((changed) => {
      this.plugin.settings.deselectKeys = changed;
      this.plugin.saveSettings();
    });
  }
};

// src/settings/keys/index.ts
var descriptions = [
  "Set keys to trigger actions.",
  "You can set multiple keys(not sequence on keys) to trigger an internal action.",
  "To set multiple keys, separate each key with a space.",
  "[Note] You should use KeyboardEvent.key property value.",
  "[Note] Restart is needed to apply changes."
];
var KeysSettings = class {
  constructor(containerEl, plugin) {
    containerEl.createEl("h1", { text: "Keys" });
    containerEl.createDiv({ cls: "setting-item-description" }, (desc) => {
      descriptions.forEach((text, idx) => {
        desc.createSpan({ text });
        if (idx + 1 < descriptions.length)
          desc.createEl("br");
      });
    });
    containerEl.createEl("br");
    new NextBlockKeysSetting(containerEl, plugin);
    new PrevBlockKeysSetting(containerEl, plugin);
    new ToggleCollapseKeysSetting(containerEl, plugin);
    new DeselectBlockKeysSetting(containerEl, plugin);
  }
};

// src/settings/miscellaneous/always-on-collapse-indicator.ts
var import_obsidian9 = require("obsidian");
var AlwaysOnCollapseIndicatorSetting = class extends import_obsidian9.Setting {
  constructor(settingsTabEl, plugin) {
    super(settingsTabEl);
    this.plugin = plugin;
    this.setName("Always on collapse indicator").setDesc("Set collapse indicators always visible in reading view.").addToggle((toggle) => this.alwaysOnCollapseIndicator(toggle));
  }
  /**
   * Creates toggle component
   *
   * @param toggle Toggle component
   */
  alwaysOnCollapseIndicator(toggle) {
    const { settings } = this.plugin;
    toggle.setValue(settings.alwaysOnCollapseIndicator).onChange((changed) => {
      settings.alwaysOnCollapseIndicator = changed;
      this.plugin.saveSettings();
      this.plugin.applyAlwaysOnCollapse(true);
    });
  }
};

// src/settings/miscellaneous/auto-select-top-block.ts
var import_obsidian10 = require("obsidian");
var AutoSelectTopBlockSetting = class extends import_obsidian10.Setting {
  constructor(settingsTabEl, plugin) {
    super(settingsTabEl);
    this.plugin = plugin;
    this.setName("Auto-select top block").setDesc(
      "Auto-select the top block in the view when switching into the reading view."
    ).addToggle((toggle) => this.autoSelectTopBlock(toggle));
  }
  /**
   * Creates toggle component
   *
   * @param toggle Toggle component
   */
  autoSelectTopBlock(toggle) {
    const { settings } = this.plugin;
    toggle.setValue(settings.autoSelectTopBlock).onChange((changed) => {
      settings.autoSelectTopBlock = changed;
      this.plugin.saveSettings();
    });
  }
};

// src/settings/miscellaneous/collapse-indicators-on-the-right-side.ts
var import_obsidian11 = require("obsidian");
var description = [
  "Set collapse indicators to be shown on the right side.",
  "Since this makes some elements relative that were previously not, may lead some problems."
];
var CollapseIndicatorsOnTheRightSideSetting = class extends import_obsidian11.Setting {
  constructor(settingsTabEl, plugin) {
    super(settingsTabEl);
    this.plugin = plugin;
    this.setName("[Experimental] Collapse indicator on the right side").setDesc(description.join(" ")).addToggle((toggle) => this.collapseIndicatorOnTheRightSide(toggle));
  }
  /**
   * Creates toggle component
   *
   * @param toggle Toggle component
   */
  collapseIndicatorOnTheRightSide(toggle) {
    const { settings } = this.plugin;
    toggle.setValue(settings.collapseIndicatorOnTheRightSide).onChange((changed) => {
      settings.collapseIndicatorOnTheRightSide = changed;
      this.plugin.saveSettings();
      this.plugin.applyCollapseIndicatorOnTheRightSide(true);
    });
  }
};

// src/settings/miscellaneous/checkbox-align-with-indentation-guide.ts
var import_obsidian12 = require("obsidian");
var description2 = [
  "Align checkboxes(task list item) to indentation guide line."
];
var AlignCheckboxToIndentationGuide2 = class extends import_obsidian12.Setting {
  constructor(settingsTabEl, plugin) {
    super(settingsTabEl);
    this.plugin = plugin;
    this.setName("Align checkbox to indentation guide").setDesc(description2.join(" ")).addToggle((toggle) => this.alignCheckboxToIndentationGuide(toggle));
  }
  /**
   * Creates toggle component
   *
   * @param toggle Toggle component
   */
  alignCheckboxToIndentationGuide(toggle) {
    const { settings } = this.plugin;
    toggle.setValue(settings.alignCheckboxToIndentationGuide).onChange((changed) => {
      settings.alignCheckboxToIndentationGuide = changed;
      this.plugin.saveSettings();
      this.plugin.applyAlignCheckboxToIndentationGuide(true);
    });
  }
};

// src/settings/miscellaneous/scrollable-code.ts
var import_obsidian13 = require("obsidian");
var ScrollableCodeSetting = class extends import_obsidian13.Setting {
  constructor(containerEl, plugin) {
    super(containerEl);
    this.plugin = plugin;
    this.setName("Scrollable code").setDesc("Make code blocks scrollable instead of line break.").addToggle((toggle) => this.setCodeScrollable(toggle));
  }
  setCodeScrollable(toggle) {
    toggle.setValue(this.plugin.settings.scrollableCode);
    toggle.onChange((changed) => {
      this.plugin.settings.scrollableCode = changed;
      this.plugin.saveSettings();
      this.plugin.applyScrollableCode(true);
    });
  }
};

// src/settings/miscellaneous/index.ts
var MiscellaneousSettings = class {
  constructor(containerEl, plugin) {
    containerEl.createEl("h1", { text: "Miscellaneous" });
    new AlwaysOnCollapseIndicatorSetting(containerEl, plugin);
    new ScrollableCodeSetting(containerEl, plugin);
    new AutoSelectTopBlockSetting(containerEl, plugin);
    new CollapseIndicatorsOnTheRightSideSetting(containerEl, plugin);
    new AlignCheckboxToIndentationGuide2(containerEl, plugin);
  }
};

// src/settings/index.ts
var DEFAULT_SETTINGS = {
  blockColor: {
    color: "rgba(139, 108, 239, 1)",
    // Obsidian default color
    transparency: 20
  },
  enableBlockSelector: true,
  disableBlockSelectorOnMobile: false,
  alwaysOnCollapseIndicator: false,
  scrollableCode: false,
  autoSelectTopBlock: false,
  collapseIndicatorOnTheRightSide: false,
  alignCheckboxToIndentationGuide: false,
  nextBlockKeys: "ArrowDown KeyJ",
  prevBlockKeys: "ArrowUp KeyK",
  toggleCollapseKeys: "ArrowLeft ArrowRight KeyH KeyL",
  deselectKeys: "Escape"
};
var RveSettingTab = class extends import_obsidian14.PluginSettingTab {
  constructor(plugin) {
    super(plugin.app, plugin);
    this.plugin = plugin;
  }
  /**
   * Displays settings tab.
   */
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new BlockSelectorSettings(containerEl, this.plugin);
    new MiscellaneousSettings(containerEl, this.plugin);
    new KeysSettings(containerEl, this.plugin);
  }
};

// src/commands/commands.ts
var commands_exports = {};
__export(commands_exports, {
  rerenderAllReadingViews: () => rerenderAllReadingViews,
  selectTopBlockInTheView: () => selectTopBlockInTheView,
  toggleBlockHighlight: () => toggleBlockHighlight
});

// src/utils.ts
var import_obsidian15 = require("obsidian");
function getReadingViewContainer(activeView) {
  if (activeView == null)
    return null;
  return activeView.previewMode.containerEl;
}
function isReadingView(activeView) {
  if (activeView == null)
    return false;
  else
    return activeView.currentMode === activeView.previewMode;
}
function getActiveView(plugin) {
  const { workspace } = plugin.app;
  return workspace.getActiveViewOfType(import_obsidian15.MarkdownView);
}

// src/commands/commands.ts
var import_obsidian16 = require("obsidian");
var rerenderAllReadingViews = (plugin) => ({
  id: "rerender-all-reading-views",
  name: "Rerender all reading views",
  callback: () => {
    const { workspace } = plugin.app;
    workspace.getLeavesOfType("markdown").forEach((leaf) => {
      var _a;
      if (leaf.view.getState().mode === "preview") {
        (_a = leaf.view.previewMode) == null ? void 0 : _a.rerender(true);
      }
    });
  }
});
var selectTopBlockInTheView = (plugin) => ({
  id: "select-top-block-in-the-view",
  name: "Select Top Block in the View",
  checkCallback: (checking) => {
    const activeView = getActiveView(plugin);
    if (checking) {
      if (!isReadingView(activeView))
        return false;
      else if (isNotEnabled(plugin))
        return false;
      else if (isMobileAndDisabled(plugin))
        return false;
      else
        return true;
    } else {
      const container = getReadingViewContainer(activeView);
      if (container) {
        plugin.blockSelector.selectTopBlockInTheView(container);
      }
      return true;
    }
  }
});
var toggleBlockHighlight = (plugin) => ({
  id: "toggle-block-highlight",
  name: "Toggle Block Highlight",
  checkCallback: (checking) => {
    const activeView = getActiveView(plugin);
    if (checking) {
      if (!isReadingView(activeView))
        return false;
      else if (isNotEnabled(plugin))
        return false;
      else if (isMobileAndDisabled(plugin))
        return false;
      else
        return true;
    } else {
      const container = getReadingViewContainer(activeView);
      if (container) {
        plugin.blockSelector.toggleBlockHighlight();
      }
      return true;
    }
  }
});
var isNotEnabled = (plugin) => {
  return !plugin.settings.enableBlockSelector;
};
var isMobileAndDisabled = (plugin) => {
  return (import_obsidian16.Platform.isMobile || import_obsidian16.Platform.isMobileApp) && plugin.settings.disableBlockSelectorOnMobile;
};

// src/commands/index.ts
var Commands = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  register() {
    Object.values(commands_exports).map((revCommand) => revCommand(this.plugin)).forEach((command) => this.plugin.addCommand(command));
  }
};

// src/block-selector/index.ts
var import_obsidian17 = require("obsidian");

// src/block-selector/selection-util.ts
var isBottomInView = (block) => {
  const rect = block.getBoundingClientRect();
  return rect.bottom <= window.innerHeight;
};
var scrollBottomIntoView = (block) => {
  const rect = block.getBoundingClientRect();
  const scrollable = getScrollParent(block);
  scrollable == null ? void 0 : scrollable.scrollBy({
    behavior: "auto",
    top: rect.bottom - scrollable.clientHeight + 200
  });
};
var isTopInView = (block) => {
  const rect = block.getBoundingClientRect();
  return rect.top >= 0;
};
var scrollTopIntoView = (block) => {
  const rect = block.getBoundingClientRect();
  const scrollable = getScrollParent(block);
  scrollable == null ? void 0 : scrollable.scrollBy({
    behavior: "auto",
    top: rect.top - 200
  });
};
var findNextBlock = (currentElement) => {
  let nextBlock = null;
  if (!isCollapsed(currentElement)) {
    const children = currentElement.children;
    for (let i = 0; i < children.length; i++) {
      nextBlock = findBlock(children[i]);
      if (nextBlock)
        return nextBlock;
    }
  }
  let nextSibling = currentElement.nextElementSibling;
  while (nextSibling) {
    nextBlock = findBlock(nextSibling);
    if (nextBlock)
      return nextBlock;
    nextSibling = nextSibling.nextElementSibling;
  }
  let parent = currentElement.parentElement;
  while (parent && !parent.hasClass(MARKDOWN_PREVIEW_VIEW)) {
    let parentSibling = parent.nextElementSibling;
    while (parentSibling) {
      nextBlock = findBlock(parentSibling);
      if (nextBlock)
        return nextBlock;
      parentSibling = parentSibling.nextElementSibling;
    }
    parent = parent.parentElement;
  }
  return null;
};
var findPreviousBlock = (currentElement) => {
  let prevSibling = currentElement.previousElementSibling;
  while (prevSibling) {
    const prevBlock = findLastBlock(prevSibling);
    if (prevBlock)
      return prevBlock;
    prevSibling = prevSibling.previousElementSibling;
  }
  let parent = currentElement.parentElement;
  while (parent && !parent.classList.contains(MARKDOWN_PREVIEW_VIEW)) {
    if (isBlock(parent))
      return parent;
    let parentSibling = parent.previousElementSibling;
    while (parentSibling) {
      const prevBlock = findLastBlock(parentSibling);
      if (prevBlock)
        return prevBlock;
      parentSibling = parentSibling.previousElementSibling;
    }
    parent = parent.parentElement;
  }
  return null;
};
var isCollapsed = (element) => {
  return element.hasClass(IS_COLLAPSED);
};
var findBlock = (element) => {
  if (isBlock(element)) {
    return element;
  }
  let block = null;
  const childElements = element.children;
  for (let i = 0; i < childElements.length; i++) {
    block = findBlock(childElements[i]);
    if (block)
      return block;
  }
  return null;
};
var findLastBlock = (element) => {
  if (isCollapsed(element) && isBlock(element))
    return element;
  let block = null;
  const childElements = element.children;
  for (let i = childElements.length - 1; i >= 0; i--) {
    block = findLastBlock(childElements[i]);
    if (block)
      return block;
  }
  if (isBlock(element))
    return element;
  else
    return null;
};
var isBlock = (element) => {
  return element.getAttribute(BLOCK_ATTR) === "true";
};
var getScrollParent = (node) => {
  if (node == null)
    return null;
  if (node.scrollHeight > node.clientHeight) {
    return node;
  } else {
    return getScrollParent(node.parentNode);
  }
};

// src/block-selector/selection-handler.ts
var SelectionHandler = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.selectedBlock = null;
    this.nextBlockKeys = plugin.settings.nextBlockKeys.split(" ");
    this.prevBlockKeys = plugin.settings.prevBlockKeys.split(" ");
    this.toggleCollapseKeys = plugin.settings.toggleCollapseKeys.split(" ");
    this.deselectKeys = plugin.settings.deselectKeys.split(" ");
  }
  isSelected(block) {
    return block === this.selectedBlock;
  }
  /**
   * Select block element
   *
   * @param block {HTMLElement} Block element
   */
  select(block) {
    block.focus();
    block.addClass(SELECTED_BLOCK);
    this.selectedBlock = block;
  }
  /**
   * Deselect block element.
   * If there is no selected block, do nothing.
   */
  deselect() {
    if (this.selectedBlock) {
      this.selectedBlock.removeClass(SELECTED_BLOCK);
      this.selectedBlock.blur();
    }
  }
  /**
   * Record the starting point of mouse or touch event.
   *
   * @param e Mouse or touch event
   */
  handleMouseTouchStart(e) {
    const { x, y } = this.clientXY(e);
    this.startX = x;
    this.startY = y;
  }
  /**
   * Calculate the distance between the starting point and the end point.
   * If the distance is less than 10, it is considered as a tap and
   * fires the `handleTap` method.
   *
   * @param e Mouse or touch event
   */
  handleMouseTouchEnd(e) {
    const { x: endX, y: endY } = this.clientXY(e);
    const distance = Math.sqrt(
      Math.pow(endX - this.startX, 2) + Math.pow(endY - this.startY, 2)
    );
    if (distance < 10) {
      this.handleTap(e);
    }
  }
  /**
   * Select or toggle collapse on tap.
   *
   * @param e Mouse or touch event
   */
  handleTap(e) {
    const target = e.target;
    const block = target.closest(`[${BLOCK_ATTR}=true]`);
    if (block instanceof HTMLElement) {
      if (this.isSelected(block)) {
        this.toggleCollapse(block);
      } else {
        this.select(block);
      }
    }
  }
  clientXY(e) {
    if (e instanceof MouseEvent) {
      return { x: e.clientX, y: e.clientY };
    } else {
      return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
  }
  /**
   * On keydown, navigate between blocks or toggle collapse.
   *
   * If selected block is too long,
   * `ArrowDown` and `ArrowUp` scrolls to see the element's bottom or top.
   * This is for loading adjacent blocks which are not in the DOM tree.
   *
   * @param e {KeyboardEvent} Keyboard event
   */
  onKeyDown(e) {
    if (!isReadingView(getActiveView(this.plugin)))
      return;
    const block = e.target;
    if (this.pressed(this.nextBlockKeys, e)) {
      e.preventDefault();
      this.selectNextBlockOrScroll(block);
    } else if (this.pressed(this.prevBlockKeys, e)) {
      e.preventDefault();
      this.selectPreviousBlockOrScroll(block);
    } else if (this.pressed(this.toggleCollapseKeys, e)) {
      e.preventDefault();
      this.toggleCollapse(block);
    } else if (this.pressed(this.deselectKeys, e)) {
      this.deselect();
    }
  }
  pressed(keysOrCodes, e) {
    return keysOrCodes.includes(e.code) || keysOrCodes.includes(e.key);
  }
  /**
   * Select next block or scroll to see the block's bottom.
   *
   * @param block {HTMLElement} Block element
   */
  selectNextBlockOrScroll(block) {
    if (!isBottomInView(block)) {
      scrollBottomIntoView(block);
    } else {
      const next = findNextBlock(block);
      if (next)
        this.select(next);
    }
  }
  /**
   * Select previous block or scroll to see the block's top.
   *
   * @param block {HTMLElement} Block element
   */
  selectPreviousBlockOrScroll(block) {
    if (!isTopInView(block)) {
      scrollTopIntoView(block);
    } else {
      const prev = findPreviousBlock(block);
      if (prev)
        this.select(prev);
    }
  }
  /**
   * Select top block in the view
   *
   * @param viewContainer {HTMLElement} View container element
   */
  selectTopBlockInTheView(viewContainer) {
    const blocks = viewContainer.querySelectorAll(`[${BLOCK_ATTR}=true]`);
    if (blocks.length === 0)
      return;
    let topIndex = -1;
    for (let i = 0; i < blocks.length; i++) {
      topIndex = i;
      const rect = blocks[i].getBoundingClientRect();
      if (rect.bottom > 120) {
        break;
      }
    }
    const topBlock = blocks[topIndex];
    this.select(topBlock);
  }
  /**
   * Toggle collapse.
   *
   * @param block Block element
   */
  toggleCollapse(block) {
    const collapseIndicator = block.querySelector(
      COLLAPSE_INDICATORS.join(",")
    );
    if (collapseIndicator) {
      collapseIndicator.click();
    }
  }
  /**
   * Toggle block highlight.
   */
  async selectedBlockHighlight() {
    if (this.selectedBlock == null)
      return;
    await this.toggleBlockHighlight(this.selectedBlock);
  }
  /**
   * Toggles highlight of the given block element.
   *
   * @param block Block element to toggle highlight
   */
  async toggleBlockHighlight(block) {
    const view = getActiveView(this.plugin);
    if (view == null || view.file == null)
      return;
    const editor = view.editor;
    const lineStartStr = block.getAttribute("data-rve-line-start");
    const lineEndStr = block.getAttribute("data-rve-line-end");
    if (!lineStartStr || !lineEndStr)
      return;
    const lineStart = parseInt(lineStartStr, 10);
    const lineEnd = parseInt(lineEndStr, 10);
    const startPos = { line: lineStart, ch: 0 };
    const endPos = { line: lineEnd, ch: view.editor.getLine(lineEnd).length };
    const selectedText = editor.getRange(startPos, endPos);
    this.changeMode("source");
    view.containerEl.style.visibility = "hidden";
    if (selectedText.startsWith("==") && selectedText.endsWith("==")) {
      editor.replaceRange(selectedText.slice(2, -2), startPos, endPos);
    } else {
      editor.replaceRange("==" + selectedText + "==", startPos, endPos);
    }
    this.changeMode("preview");
    view.containerEl.style.visibility = "visible";
  }
  changeMode(mode) {
    const view = getActiveView(this.plugin);
    if (view == null)
      return;
    const state = view.getState();
    view.setState({ ...state, mode }, { history: true });
  }
};

// src/block-selector/index.ts
var BlockSelector = class {
  /**
   * Initialize BlockSelector.
   * Register markdown post processor to blockify some elements.
   *
   * @param plugin {ReadingViewEnhancer} Plugin instance
   */
  constructor(plugin) {
    this.plugin = plugin;
    this.selectionHandler = new SelectionHandler(plugin);
  }
  /**
   * Activate BlockSelector
   */
  activate() {
    this.plugin.registerMarkdownPostProcessor(this.blockify.bind(this));
    this.plugin.registerEvent(
      this.plugin.app.workspace.on(
        "layout-change",
        this.autoSelectTopBlock.bind(this)
      )
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on(
        "active-leaf-change",
        this.autoSelectTopBlock.bind(this)
      )
    );
  }
  autoSelectTopBlock() {
    if (!this.plugin.settings.autoSelectTopBlock)
      return;
    const view = getActiveView(this.plugin);
    if (isReadingView(view)) {
      const containerEl = getReadingViewContainer(view);
      if (containerEl) {
        this.selectTopBlockInTheView(containerEl);
      }
    }
  }
  /**
   * Select top block in the view
   *
   * @param viewContainer {HTMLElement} View container element
   */
  selectTopBlockInTheView(viewContainer) {
    this.selectionHandler.selectTopBlockInTheView(viewContainer);
  }
  toggleBlockHighlight() {
    this.selectionHandler.selectedBlockHighlight();
  }
  /**
   * Blockify some elements.
   * If container is not initialized, initialize it.
   * Transform some elements to block elements.
   */
  blockify(element, context) {
    if (!this.plugin.settings.enableBlockSelector)
      return;
    if ((import_obsidian17.Platform.isMobile || import_obsidian17.Platform.isMobileApp) && this.plugin.settings.disableBlockSelectorOnMobile) {
      return;
    }
    const container = context == null ? void 0 : context.containerEl;
    if (this.isContainerNotInitialized(container)) {
      this.initializeContainer(container);
    }
    this.elementsToBlocks(element, context);
  }
  /**
   * Check if container is initialized.
   *
   * @param container Container element
   * @returns True if container is initialized
   */
  isContainerNotInitialized(container) {
    return container instanceof HTMLElement && !container.hasClass(BLOCK_SELECTOR);
  }
  /**
   * Initialize container.
   * Add some event listeners to container.
   *
   * @param container Container element
   */
  initializeContainer(container) {
    container.addClass(BLOCK_SELECTOR);
    container.addEventListener(
      "mousedown",
      this.selectionHandler.handleMouseTouchStart.bind(this.selectionHandler)
    );
    container.addEventListener(
      "touchstart",
      this.selectionHandler.handleMouseTouchStart.bind(this.selectionHandler)
    );
    container.addEventListener(
      "mouseup",
      this.selectionHandler.handleMouseTouchEnd.bind(this.selectionHandler)
    );
    container.addEventListener(
      "touchend",
      this.selectionHandler.handleMouseTouchEnd.bind(this.selectionHandler)
    );
    container.addEventListener(
      "focusout",
      this.selectionHandler.deselect.bind(this.selectionHandler)
    );
    container.addEventListener(
      "keydown",
      this.selectionHandler.onKeyDown.bind(this.selectionHandler)
    );
  }
  /**
   * Set `data-rve-block` attribute to block elements.
   *
   * @param element Element to start searching
   */
  elementsToBlocks(element, context) {
    const section = context.getSectionInfo(element);
    const elements = element.querySelectorAll(BLOCKS.join(", "));
    elements.forEach((el) => {
      if (el.hasClass(FRONTMATTER))
        return;
      el.setAttribute(BLOCK_ATTR, "true");
      el.setAttribute("tabindex", "-1");
      if ((section == null ? void 0 : section.lineStart) && (section == null ? void 0 : section.lineEnd)) {
        el.setAttribute("data-rve-line-start", section.lineStart.toString());
        el.setAttribute("data-rve-line-end", section.lineEnd.toString());
      }
    });
  }
};

// src/main.ts
var ReadingViewEnhancer = class extends import_obsidian18.Plugin {
  /**
   * On load,
   *
   * - Load settings & styles
   * - Activate block selector
   *     - It actually do its work if settings.enableBlockSelector is true
   * - Register all commands
   * - Add settings tab
   */
  async onload() {
    await this.loadSettings();
    this.styles = new RveStyles();
    this.app.workspace.onLayoutReady(() => this.applySettingsToStyles());
    this.blockSelector = new BlockSelector(this);
    this.blockSelector.activate();
    new Commands(this).register();
    this.addSettingTab(new RveSettingTab(this));
    console.log("Loaded 'Reading View Enhancer'");
  }
  /**
   * On unload,
   *
   * - Remove all styles
   */
  async onunload() {
    this.styles.cleanup();
    console.log("Unloaded 'Reading View Enhancer'");
  }
  // ===================================================================
  /**
   * Load settings
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Save settings
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Apply settings to styles
   *
   * - Apply block color
   * - Apply always on collapse indicator
   * - Apply scrollable code
   */
  applySettingsToStyles() {
    this.applyBlockColor();
    this.applyAlwaysOnCollapse();
    this.applyScrollableCode();
    this.applyCollapseIndicatorOnTheRightSide();
    this.applyAlignCheckboxToIndentationGuide();
    this.styles.apply();
  }
  /**
   * Apply block color
   *
   * @param isImmediate Whether to apply styles immediately
   */
  applyBlockColor(isImmediate = false) {
    const blockColor = this.styles.of("block-color");
    blockColor.set(this.settings.blockColor);
    if (isImmediate)
      this.styles.apply();
  }
  /**
   * Apply always on collapse indicator
   *
   * @param isImmediate Whether to apply styles immediately
   */
  applyAlwaysOnCollapse(isImmediate = false) {
    this.styles.of("collapse-indicator-always-on").isActive = this.settings.alwaysOnCollapseIndicator;
    if (isImmediate)
      this.styles.apply();
  }
  /**
   * Apply collapse indicator on the right side
   *
   * @param isImmediate Whether to apply styles immediately
   */
  applyCollapseIndicatorOnTheRightSide(isImmediate = false) {
    const rightIndicator = this.styles.of(
      "collapse-indicator-on-the-right-side"
    );
    rightIndicator.isCheckboxAligned = this.settings.alignCheckboxToIndentationGuide;
    rightIndicator.isActive = this.settings.collapseIndicatorOnTheRightSide;
    if (isImmediate)
      this.styles.apply();
  }
  /**
   * Apply checkbox align with indentation guide
   *
   * @param isImmediate Whether to apply styles immediately
   */
  applyAlignCheckboxToIndentationGuide(isImmediate = false) {
    this.styles.of("align-checkbox-to-indentation-guide").isActive = this.settings.alignCheckboxToIndentationGuide;
    const rightIndicator = this.styles.of(
      "collapse-indicator-on-the-right-side"
    );
    rightIndicator.isCheckboxAligned = this.settings.alignCheckboxToIndentationGuide;
    if (isImmediate)
      this.styles.apply();
  }
  /**
   * Apply scrollable code
   *
   * @param isImmediate Whether to apply styles immediately
   */
  applyScrollableCode(isImmediate = false) {
    this.styles.of("scrollable-code").isActive = this.settings.scrollableCode;
    if (isImmediate)
      this.styles.apply();
  }
};

/* nosourcemap */